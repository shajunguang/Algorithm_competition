1.什么是精确覆盖？（NP问题）
覆盖：S为集合X的若干个子集构成的集合，若存在S的一个子集S*,S*=Us(s为S中的元素）
则称S*为X的一个覆盖,当s之间交集为空的时候,S*为X的精确覆盖。
假定 S = { A, B, C, D} ,X = {1, 2, 3, 4, 5, 6} ,其中：
A = {1, 3, 5}
B = {2, 4}
C = {2, 3, 4, 5, 6}
D = {2, 4, 6}
那么 S* = {A, D} 是 X 的一个精确覆盖。而 {A, B}、{A, C}
分别不满足上述属性2、1，因而不是 X 的一个精确覆盖。

2.Algorithm-X算法
维护两个集合——当前尚未满足的限制条件和可供选择的选项。
1.检查当前未满足的限制条件集合，若为空，则表示问题已经解决，输出答案并返回
2.否则选择其中一个不满足的限制条件。（可以使用启发式算法尽量加快代码运行）
3.找满足限制条件的选项集合，若为空，则表示当前这个位置不可能产出正确答案，返回。（剪枝）
4.否则，遍历上述选项集合（这一步可以是随机选择，这样会导致一个 non-deterministic 算法）：
（1）当前选项可能满足多个限制条件，故对每个满足的限制条件，将其从未满足限制条件集合中移除，
并且将所有能满足这个限制条件的选项也移除（因为精确覆盖要求不可重叠，若考虑完全覆盖则此时不需要移除）
（2）上述操作完成后形成“尚未满足的限制条件”和“可供选择的选项”这两个集合的子集合——即子问题，
对此子问题递归求解。
（3）复原：上述递归完成后，在测试下一个选项前，我们需要恢复原来两个集合的样子。
所以要将之前移除的条件和选项全部恢复。

3.Dancing Links
双向链表，交叉十字循环双向链
1> 判断head->right == head？成立，返回答案，不成立，下一步。
2> 删除nextCell=head->right(删除的意思和链表中的删除一样，移除掉上下左右的指向关系)，同时删除
所在列所有点所在的所有行的元素。若存在多行，可以随机选择一行作为答案弹入栈ans.
3>nextCell->down == nextCell？成立表示这一列所有的元素被删完了，不存在解，需要回溯（5）。
4>遍历nextCell,重复2,1.
5>回溯过程，就是按照删除的顺序逆序恢复，先进后出？堆栈来了！
